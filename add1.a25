<
Adds one to a 16 bit signed or unsigned integer.
This is extremely fast.
Uses bubble sort to identify the lowest 0-1 edge,
then makes all of the ones to the right of that zeros
and sets the zero to a one on the edge.

00100111
    ^^ edge
output:
00101000
    ^set to one
     ^^^ set to zero

Number stored at f000 and number+1 is outputted to f001.
>
0000 imm addr0 ffff 0001
0001 imm addr1 f000 0002
0002 imm gen1 ffff 0003
0003 ram gen0 0000 0004
<
Have now loaded the inverse of the number to have 1 added
to it.
>
0004 gen jzor 00ff 0006
0006 gen jzor 0fff 0008
0007 gen jzor 000f 000a
0008 gen jzor 3fff 000c
0009 gen jzor 03ff 000e
000a gen jzor 003f 0010
000b gen jzor 0003 0012
000c gen jzor 7fff 0014
000d gen jzor 1fff 0016
000e gen jzor 07ff 0018
000f gen jzor 01ff 001a
0010 gen jzor 007f 001c
0011 gen jzor 001f 001e
0012 gen jzor 0007 0020
0013 gen jzor 0001 0022
0014 gen jzor ffff 0024
0015 imm gen1 3fff 0026
0016 imm gen1 1fff 0027
0017 imm gen1 0fff 0028
0018 imm gen1 07ff 0029
0019 imm gen1 03ff 002a
001a imm gen1 01ff 002b
001b imm gen1 00ff 002c
001c imm gen1 007f 002d
001d imm gen1 003f 002e
001e imm gen1 001f 002f
001f imm gen1 000f 0030
0020 imm gen1 0007 0031
0021 imm gen1 0003 0032
0022 imm gen1 0001 0033
0023 imm gen0 0001 
0024 imm gen1 ffff 
0025 imm gen1 7fff 0034
0026 imm gen0 4000 
0027 imm gen0 2000 
0028 imm gen0 1000 
0029 imm gen0 0800 
002a imm gen0 0400 
002b imm gen0 0200
002c imm gen0 0100 
002d imm gen0 0080 
002e imm gen0 0040 
002f imm gen0 0020
0030 imm gen0 0010 
0031 imm gen0 0008 
0032 imm gen0 0004 
0033 imm gen0 0002 
0034 imm gen0 0001
